{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"./namespace.js","imported":["DDP","LivedataTest"],"specifiers":[{"kind":"named","imported":"DDP","local":"DDP"},{"kind":"named","imported":"LivedataTest","local":"LivedataTest"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/ddp-client/stream_client_nodejs.js","filenameRelative":"packages/ddp-client/stream_client_nodejs.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/ddp-client/stream_client_nodejs.js.map","sourceFileName":"packages/ddp-client/stream_client_nodejs.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"stream_client_nodejs"},"ignored":false,"code":"const module1 = module;\nlet DDP, LivedataTest;\nmodule1.watch(require(\"./namespace.js\"), {\n  DDP(v) {\n    DDP = v;\n  },\n\n  LivedataTest(v) {\n    LivedataTest = v;\n  }\n\n}, 0);\n// @param endpoint {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n//\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\n// us should work.\n//\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\n// ping frames or with DDP-level messages.)\nLivedataTest.ClientStream = class ClientStream {\n  constructor(endpoint, options) {\n    const self = this;\n    options = options || {};\n    self.options = Object.assign({\n      retry: true\n    }, options);\n    self.client = null; // created in _launchConnection\n\n    self.endpoint = endpoint;\n    self.headers = self.options.headers || {};\n    self.npmFayeOptions = self.options.npmFayeOptions || {};\n\n    self._initCommon(self.options); //// Kickoff!\n\n\n    self._launchConnection();\n  } // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n\n\n  send(data) {\n    var self = this;\n\n    if (self.currentStatus.connected) {\n      self.client.send(data);\n    }\n  } // Changes where this connection points\n\n\n  _changeUrl(url) {\n    var self = this;\n    self.endpoint = url;\n  }\n\n  _onConnect(client) {\n    var self = this;\n\n    if (client !== self.client) {\n      // This connection is not from the last call to _launchConnection.\n      // But _launchConnection calls _cleanup which closes previous connections.\n      // It's our belief that this stifles future 'open' events, but maybe\n      // we are wrong?\n      throw new Error(\"Got open from inactive client \" + !!self.client);\n    }\n\n    if (self._forcedToDisconnect) {\n      // We were asked to disconnect between trying to open the connection and\n      // actually opening it. Let's just pretend this never happened.\n      self.client.close();\n      self.client = null;\n      return;\n    }\n\n    if (self.currentStatus.connected) {\n      // We already have a connection. It must have been the case that we\n      // started two parallel connection attempts (because we wanted to\n      // 'reconnect now' on a hanging connection and we had no way to cancel the\n      // connection attempt.) But this shouldn't happen (similarly to the client\n      // !== self.client check above).\n      throw new Error(\"Two parallel connections?\");\n    }\n\n    self._clearConnectionTimer(); // update status\n\n\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged(); // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n\n    _.each(self.eventCallbacks.reset, function (callback) {\n      callback();\n    });\n  }\n\n  _cleanup(maybeError) {\n    var self = this;\n\n    self._clearConnectionTimer();\n\n    if (self.client) {\n      var client = self.client;\n      self.client = null;\n      client.close();\n\n      _.each(self.eventCallbacks.disconnect, function (callback) {\n        callback(maybeError);\n      });\n    }\n  }\n\n  _clearConnectionTimer() {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n  }\n\n  _getProxyUrl(targetUrl) {\n    var self = this; // Similar to code in tools/http-helpers.js.\n\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null; // if we're going to a secure url, try the https_proxy env variable first.\n\n    if (targetUrl.match(/^wss:/)) {\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\n    }\n\n    return proxy;\n  }\n\n  _launchConnection() {\n    var self = this;\n\n    self._cleanup(); // cleanup the old socket, if there was one.\n    // Since server-to-server DDP is still an experimental feature, we only\n    // require the module if we actually create a server-to-server\n    // connection.\n\n\n    var FayeWebSocket = Npm.require('faye-websocket');\n\n    var deflate = Npm.require('permessage-deflate');\n\n    var targetUrl = toWebsocketUrl(self.endpoint);\n    var fayeOptions = {\n      headers: self.headers,\n      extensions: [deflate]\n    };\n    fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);\n\n    var proxyUrl = self._getProxyUrl(targetUrl);\n\n    if (proxyUrl) {\n      fayeOptions.proxy = {\n        origin: proxyUrl\n      };\n    }\n\n    ; // We would like to specify 'ddp' as the subprotocol here. The npm module we\n    // used to use as a client would fail the handshake if we ask for a\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\n    // Faye is erroneous or not.  So for now, we don't specify protocols.\n\n    var subprotocols = [];\n    var client = self.client = new FayeWebSocket.Client(targetUrl, subprotocols, fayeOptions);\n\n    self._clearConnectionTimer();\n\n    self.connectionTimer = Meteor.setTimeout(function () {\n      self._lostConnection(new DDP.ConnectionError(\"DDP connection timed out\"));\n    }, self.CONNECT_TIMEOUT);\n    self.client.on('open', Meteor.bindEnvironment(function () {\n      return self._onConnect(client);\n    }, \"stream connect callback\"));\n\n    var clientOnIfCurrent = function (event, description, f) {\n      self.client.on(event, Meteor.bindEnvironment(function () {\n        // Ignore events from any connection we've already cleaned up.\n        if (client !== self.client) return;\n        f.apply(this, arguments);\n      }, description));\n    };\n\n    clientOnIfCurrent('error', 'stream error callback', function (error) {\n      if (!self.options._dontPrintErrors) Meteor._debug(\"stream error\", error.message); // Faye's 'error' object is not a JS error (and among other things,\n      // doesn't stringify well). Convert it to one.\n\n      self._lostConnection(new DDP.ConnectionError(error.message));\n    });\n    clientOnIfCurrent('close', 'stream close callback', function () {\n      self._lostConnection();\n    });\n    clientOnIfCurrent('message', 'stream message callback', function (message) {\n      // Ignore binary frames, where message.data is a Buffer\n      if (typeof message.data !== \"string\") return;\n\n      _.each(self.eventCallbacks.message, function (callback) {\n        callback(message.data);\n      });\n    });\n  }\n\n};","map":{"version":3,"sources":["packages/ddp-client/stream_client_nodejs.js"],"names":["module1","module","DDP","LivedataTest","watch","require","v","ClientStream","constructor","endpoint","options","self","Object","assign","retry","client","headers","npmFayeOptions","_initCommon","_launchConnection","send","data","currentStatus","connected","_changeUrl","url","_onConnect","Error","_forcedToDisconnect","close","_clearConnectionTimer","status","retryCount","statusChanged","_","each","eventCallbacks","reset","callback","_cleanup","maybeError","disconnect","connectionTimer","clearTimeout","_getProxyUrl","targetUrl","proxy","process","env","HTTP_PROXY","http_proxy","match","HTTPS_PROXY","https_proxy","FayeWebSocket","Npm","deflate","toWebsocketUrl","fayeOptions","extensions","extend","proxyUrl","origin","subprotocols","Client","Meteor","setTimeout","_lostConnection","ConnectionError","CONNECT_TIMEOUT","on","bindEnvironment","clientOnIfCurrent","event","description","f","apply","arguments","error","_dontPrintErrors","_debug","message"],"mappings":"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","file":"packages/ddp-client/stream_client_nodejs.js.map","sourcesContent":["import { DDP, LivedataTest } from \"./namespace.js\";\n\n// @param endpoint {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n//\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\n// us should work.\n//\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\n// ping frames or with DDP-level messages.)\nLivedataTest.ClientStream = class ClientStream {\n  constructor(endpoint, options) {\n    const self = this;\n    options = options || {};\n\n    self.options = Object.assign({\n      retry: true\n    }, options);\n\n    self.client = null;  // created in _launchConnection\n    self.endpoint = endpoint;\n\n    self.headers = self.options.headers || {};\n    self.npmFayeOptions = self.options.npmFayeOptions || {};\n\n    self._initCommon(self.options);\n\n    //// Kickoff!\n    self._launchConnection();\n  }\n\n  // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n  send(data) {\n    var self = this;\n    if (self.currentStatus.connected) {\n      self.client.send(data);\n    }\n  }\n\n  // Changes where this connection points\n  _changeUrl(url) {\n    var self = this;\n    self.endpoint = url;\n  }\n\n  _onConnect(client) {\n    var self = this;\n\n    if (client !== self.client) {\n      // This connection is not from the last call to _launchConnection.\n      // But _launchConnection calls _cleanup which closes previous connections.\n      // It's our belief that this stifles future 'open' events, but maybe\n      // we are wrong?\n      throw new Error(\"Got open from inactive client \" + !!self.client);\n    }\n\n    if (self._forcedToDisconnect) {\n      // We were asked to disconnect between trying to open the connection and\n      // actually opening it. Let's just pretend this never happened.\n      self.client.close();\n      self.client = null;\n      return;\n    }\n\n    if (self.currentStatus.connected) {\n      // We already have a connection. It must have been the case that we\n      // started two parallel connection attempts (because we wanted to\n      // 'reconnect now' on a hanging connection and we had no way to cancel the\n      // connection attempt.) But this shouldn't happen (similarly to the client\n      // !== self.client check above).\n      throw new Error(\"Two parallel connections?\");\n    }\n\n    self._clearConnectionTimer();\n\n    // update status\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged();\n\n    // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\n  }\n\n  _cleanup(maybeError) {\n    var self = this;\n\n    self._clearConnectionTimer();\n    if (self.client) {\n      var client = self.client;\n      self.client = null;\n      client.close();\n\n      _.each(self.eventCallbacks.disconnect, function (callback) {\n        callback(maybeError);\n      });\n    }\n  }\n\n  _clearConnectionTimer() {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n  }\n\n  _getProxyUrl(targetUrl) {\n    var self = this;\n    // Similar to code in tools/http-helpers.js.\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;\n    // if we're going to a secure url, try the https_proxy env variable first.\n    if (targetUrl.match(/^wss:/)) {\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\n    }\n    return proxy;\n  }\n\n  _launchConnection() {\n    var self = this;\n    self._cleanup(); // cleanup the old socket, if there was one.\n\n    // Since server-to-server DDP is still an experimental feature, we only\n    // require the module if we actually create a server-to-server\n    // connection.\n    var FayeWebSocket = Npm.require('faye-websocket');\n    var deflate = Npm.require('permessage-deflate');\n\n    var targetUrl = toWebsocketUrl(self.endpoint);\n    var fayeOptions = {\n      headers: self.headers,\n      extensions: [deflate]\n    };\n    fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);\n    var proxyUrl = self._getProxyUrl(targetUrl);\n    if (proxyUrl) {\n      fayeOptions.proxy = { origin: proxyUrl };\n    };\n\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we\n    // used to use as a client would fail the handshake if we ask for a\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\n    // Faye is erroneous or not.  So for now, we don't specify protocols.\n    var subprotocols = [];\n\n    var client = self.client = new FayeWebSocket.Client(\n      targetUrl, subprotocols, fayeOptions);\n\n    self._clearConnectionTimer();\n    self.connectionTimer = Meteor.setTimeout(\n      function () {\n        self._lostConnection(\n          new DDP.ConnectionError(\"DDP connection timed out\"));\n      },\n      self.CONNECT_TIMEOUT);\n\n    self.client.on('open', Meteor.bindEnvironment(function () {\n      return self._onConnect(client);\n    }, \"stream connect callback\"));\n\n    var clientOnIfCurrent = function (event, description, f) {\n      self.client.on(event, Meteor.bindEnvironment(function () {\n        // Ignore events from any connection we've already cleaned up.\n        if (client !== self.client)\n          return;\n        f.apply(this, arguments);\n      }, description));\n    };\n\n    clientOnIfCurrent('error', 'stream error callback', function (error) {\n      if (!self.options._dontPrintErrors)\n        Meteor._debug(\"stream error\", error.message);\n\n      // Faye's 'error' object is not a JS error (and among other things,\n      // doesn't stringify well). Convert it to one.\n      self._lostConnection(new DDP.ConnectionError(error.message));\n    });\n\n\n    clientOnIfCurrent('close', 'stream close callback', function () {\n      self._lostConnection();\n    });\n\n\n    clientOnIfCurrent('message', 'stream message callback', function (message) {\n      // Ignore binary frames, where message.data is a Buffer\n      if (typeof message.data !== \"string\")\n        return;\n\n      _.each(self.eventCallbacks.message, function (callback) {\n        callback(message.data);\n      });\n    });\n  }\n};\n"]},"hash":"ba6f333008420f4e92ecf12cc86b711a878c5d43"}

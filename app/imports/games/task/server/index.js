import { RegisterGame } from "../../../core/api/games/register";
import { avatarPaths, difficulties, maxOutDegree, taskData } from "./constants";

RegisterGame("task", {
  // init() is called when a new game instance is starting. It allows you
  // to define all proporties of this game run.
  //
  // Game runs are started from the admin UI with 2 attributes:
  // - a `treatment` (String), which is an identifier for a (sub)game type.
  //   You might only have one game treatment (say, "default"), that's fine.
  //   In other cases, you might have a "solo" treatment, a "static" treatment
  //   and a "cooperation" treament for example. This is just a way to identify
  //   what type of subgame we want to run.
  // - a `number of players` (Int). This number of players is the amount of
  //   players you want playing this game instance. Netwise takes care of
  //   running players through the introductory phases (rules, test, etc.)
  //   and collecting the right amount of players for the game in a lobby.
  //
  // Once the right amount of players are ready, Netwise calls this init
  // function with the treatment identifier (String) and an array of Players
  // (Array[Player]). The Player objects contain player metadata collected or
  // generated by Netwise such a a unique player ID, browser/OS/Platform data,
  // information passed to Netwise when the user arrived such as a MTurk ID,
  // etc. (Details of what info the Player object starts with is TBD).
  //
  // The init function should return a Game object with 3 properties attached to
  // it:
  // - the `rounds` (Array[Round]), which describe each round the game will be
  //   composed of. The Round object is described further bellow.
  // - the `players` (Array[Player]), which is the same list of Players that was
  //   passed in but you have the opportunity to augment these Players with
  //   extra information.
  // - any extra `data` (Object, optional) that is relevant to this game
  //   instance. This could be any value you wish to store for you game that is
  //   not round or player dependent or scoped.
  //
  // The Round object describes how a Round should work from Netwise standpoint
  // (number of stages, durations) and it can contain extra metadata that you
  // want to keep about the round, such as the input value(s) (e.g. question)
  // and the expected output value (e.g. expected good answer).
  // The Round object's fields are:
  // - `stages` (Array[Stage]) which is an array Stage object, each object
  //   defining one stage of the round. The Stage object is further defined
  //   bellow
  // - `data` (Object, optional) is an open object for the game to add custom
  //   values needed in this round, such as input/output values (e.g. path to
  //   plot image, correct answer, etc.)
  //
  // The Stage object tells Netwise how the Stage should go down (duration)
  // and can also contain stage scoped game data:
  // - `id` (String) is the identifier for this stage, which can be used to
  //   programmatically identify the stage type.
  // - `name` (String) is the display name for this stage which will be diplayed
  //    in the UI.
  // - `duration` (Int) is the maximum amount of time in seconds this stage
  //   should last.
  //   If all players have submitted before the timeout, the stage might last
  //   less than duration.
  //   If the value is 0, there is no maximum duration for
  //   this stage and the next stage only happens when all users have submitted.
  // - `data` (Object, optional) is an open object for the game to add custom
  //   values needed in this stage, similarly to Rounds, Games and Players.
  //
  //
  init(treatment, players) {
    const avatars = _.shuffle(avatarPaths);

    players.forEach((player, i) => {
      const alters = _.sample(_.without(players, player), maxOutDegree);
      player.data = {
        avatar: avatars[i],
        difficulty: Random.choice(difficulties),
        alterIds: _.pluck(alters, "_id")
      };
    });

    const tasks = _.shuffle(taskData);

    const rounds = [];
    const roundCount = treatment === "solo" ? 8 : 10;
    _.times(roundCount, i => {
      const stages = [
        {
          id: "response",
          name: "Response",
          duration: 45
        }
      ];

      if (treatment !== "solo") {
        stages.push({
          id: "interactive",
          name: "Interactive Response",
          duration: 30
        });
      }

      // Dont't include a cooperative stage on the last round.
      if (treatment === "cooperative" && i !== roundCount - 1) {
        stages.push({
          id: "network",
          name: "Network update",
          duration: 30
        });
      }

      rounds.push({
        stages,
        data: {
          task: tasks[i]
        }
      });
    });

    return {
      rounds,
      players
    };
  },

  // onStageEnd is called each time a stage ends. It is a good time to
  // update the player's scores and make needed otherwise calculations.
  // onStageEnd is called for each player.
  // It arguments are:
  // - `game`, which is the same object returned by init, plus current state
  //   of the game data. The game contains all `players` and `rounds`.
  // - `round`, the current Round object (same as created in init).
  // - `stage`, the current Stage object (same as created in init). The Stage
  //   object pass in onStageEnd also has accessor methods get and set to read
  //   and write stage scoped player data.
  // - `player` is the current player
  onStageEnd(game, round, stage, player) {}
});

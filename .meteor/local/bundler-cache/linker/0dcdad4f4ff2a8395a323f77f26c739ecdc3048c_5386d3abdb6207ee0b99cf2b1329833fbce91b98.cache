[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\n\n/* Package-scope variables */\nvar makeInstaller, makeInstallerOptions, meteorInstall;\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/.npm/package/node_modules/install/install.js     //\n// This file is in bare mode and is not in its own closure.                  //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmakeInstaller = function (options) {                                         // 1\n  \"use strict\";                                                              // 2\n                                                                             // 3\n  options = options || {};                                                   // 4\n                                                                             // 5\n  // These file extensions will be appended to required module identifiers   // 6\n  // if they do not exactly match an installed module.                       // 7\n  var defaultExtensions = options.extensions || [\".js\", \".json\"];            // 8\n                                                                             // 9\n  // If defined, the options.onInstall function will be called any time      // 10\n  // new modules are installed.                                              // 11\n  var onInstall = options.onInstall;                                         // 12\n                                                                             // 13\n  // If defined, each module-specific require function will be passed to     // 14\n  // this function, along with the module object of the parent module, and   // 15\n  // the result will be used in place of the original require function.      // 16\n  var wrapRequire = options.wrapRequire;                                     // 17\n                                                                             // 18\n  // If defined, the options.override function will be called before         // 19\n  // looking up any top-level package identifiers in node_modules            // 20\n  // directories. It can either return a string to provide an alternate      // 21\n  // package identifier, or a non-string value to prevent the lookup from    // 22\n  // proceeding.                                                             // 23\n  var override = options.override;                                           // 24\n                                                                             // 25\n  // If defined, the options.fallback function will be called when no        // 26\n  // installed module is found for a required module identifier. Often       // 27\n  // options.fallback will be implemented in terms of the native Node        // 28\n  // require function, which has the ability to load binary modules.         // 29\n  var fallback = options.fallback;                                           // 30\n                                                                             // 31\n  // List of fields to look for in package.json files to determine the       // 32\n  // main entry module of the package. The first field listed here whose     // 33\n  // value is a string will be used to resolve the entry module.             // 34\n  var mainFields = options.mainFields ||                                     // 35\n    // If options.mainFields is absent and options.browser is truthy,        // 36\n    // package resolution will prefer the \"browser\" field of package.json    // 37\n    // files to the \"main\" field. Note that this only supports               // 38\n    // string-valued \"browser\" fields for now, though in the future it       // 39\n    // might make sense to support the object version, a la browserify.      // 40\n    (options.browser ? [\"browser\", \"main\"] : [\"main\"]);                      // 41\n                                                                             // 42\n  var hasOwn = {}.hasOwnProperty;                                            // 43\n  function strictHasOwn(obj, key) {                                          // 44\n    return isObject(obj) && isString(key) && hasOwn.call(obj, key);          // 45\n  }                                                                          // 46\n                                                                             // 47\n  // Cache for looking up File objects given absolute module identifiers.    // 48\n  // Invariants:                                                             // 49\n  //   filesByModuleId[module.id] === fileAppendId(root, module.id)          // 50\n  //   filesByModuleId[module.id].module === module                          // 51\n  var filesByModuleId = {};                                                  // 52\n                                                                             // 53\n  // The file object representing the root directory of the installed        // 54\n  // module tree.                                                            // 55\n  var root = new File(\"/\", new File(\"/..\"));                                 // 56\n  var rootRequire = makeRequire(root);                                       // 57\n                                                                             // 58\n  // Merges the given tree of directories and module factory functions       // 59\n  // into the tree of installed modules and returns a require function       // 60\n  // that behaves as if called from a module in the root directory.          // 61\n  function install(tree, options) {                                          // 62\n    if (isObject(tree)) {                                                    // 63\n      fileMergeContents(root, tree, options);                                // 64\n      if (isFunction(onInstall)) {                                           // 65\n        onInstall(rootRequire);                                              // 66\n      }                                                                      // 67\n    }                                                                        // 68\n    return rootRequire;                                                      // 69\n  }                                                                          // 70\n                                                                             // 71\n  // Replace this function to enable Module.prototype.prefetch.              // 72\n  install.fetch = function (ids) {                                           // 73\n    throw new Error(\"fetch not implemented\");                                // 74\n  };                                                                         // 75\n                                                                             // 76\n  // This constructor will be used to instantiate the module objects         // 77\n  // passed to module factory functions (i.e. the third argument after       // 78\n  // require and exports), and is exposed as install.Module in case the      // 79\n  // caller of makeInstaller wishes to modify Module.prototype.              // 80\n  function Module(id) {                                                      // 81\n    this.id = id;                                                            // 82\n                                                                             // 83\n    // The Node implementation of module.children unfortunately includes     // 84\n    // only those child modules that were imported for the first time by     // 85\n    // this parent module (i.e., child.parent === this).                     // 86\n    this.children = [];                                                      // 87\n                                                                             // 88\n    // This object is an install.js extension that includes all child        // 89\n    // modules imported by this module, even if this module is not the       // 90\n    // first to import them.                                                 // 91\n    this.childrenById = {};                                                  // 92\n  }                                                                          // 93\n                                                                             // 94\n  Module.prototype.resolve = function (id) {                                 // 95\n    return this.require.resolve(id);                                         // 96\n  };                                                                         // 97\n                                                                             // 98\n  // Used to keep module.prefetch promise resolutions well-ordered.          // 99\n  var lastPrefetchPromise;                                                   // 100\n                                                                             // 101\n  // May be shared by multiple sequential calls to module.prefetch.          // 102\n  // Initialized to {} only when necessary.                                  // 103\n  var missing;                                                               // 104\n                                                                             // 105\n  Module.prototype.prefetch = function (id) {                                // 106\n    var module = this;                                                       // 107\n    var parentFile = getOwn(filesByModuleId, module.id);                     // 108\n                                                                             // 109\n    lastPrefetchPromise = lastPrefetchPromise || Promise.resolve();          // 110\n    var previousPromise = lastPrefetchPromise;                               // 111\n                                                                             // 112\n    function walk(module) {                                                  // 113\n      var file = getOwn(filesByModuleId, module.id);                         // 114\n      if (fileIsDynamic(file) && ! file.pending) {                           // 115\n        file.pending = true;                                                 // 116\n        missing = missing || {};                                             // 117\n                                                                             // 118\n        // These are the data that will be exposed to the install.fetch      // 119\n        // callback, so it's worth documenting each item with a comment.     // 120\n        missing[module.id] = {                                               // 121\n          // The CommonJS module object that will be exposed to this         // 122\n          // dynamic module when it is evaluated. Note that install.fetch    // 123\n          // could decide to populate module.exports directly, instead of    // 124\n          // fetching anything. In that case, install.fetch should omit      // 125\n          // this module from the tree that it produces.                     // 126\n          module: file.module,                                               // 127\n          // List of module identifier strings imported by this module.      // 128\n          // Note that the missing object already contains all available     // 129\n          // dependencies (including transitive dependencies), so            // 130\n          // install.fetch should not need to traverse these dependencies    // 131\n          // in most cases; however, they may be useful for other reasons.   // 132\n          // Though the strings are unique, note that two different          // 133\n          // strings could resolve to the same module.                       // 134\n          deps: Object.keys(file.deps),                                      // 135\n          // The options (if any) that were passed as the second argument    // 136\n          // to the install(tree, options) function when this stub was       // 137\n          // first registered. Typically contains options.extensions, but    // 138\n          // could contain any information appropriate for the entire tree   // 139\n          // as originally installed. These options will be automatically    // 140\n          // inherited by the newly fetched modules, so install.fetch        // 141\n          // should not need to modify them.                                 // 142\n          options: file.options,                                             // 143\n          // Any stub data included in the array notation from the           // 144\n          // original entry for this dynamic module. Typically contains      // 145\n          // \"main\" and/or \"browser\" fields for package.json files, and is   // 146\n          // otherwise undefined.                                            // 147\n          stub: file.stub                                                    // 148\n        };                                                                   // 149\n                                                                             // 150\n        each(file.deps, function (parentId, id) {                            // 151\n          fileResolve(file, id);                                             // 152\n        });                                                                  // 153\n                                                                             // 154\n        each(module.childrenById, walk);                                     // 155\n      }                                                                      // 156\n    }                                                                        // 157\n                                                                             // 158\n    return lastPrefetchPromise = new Promise(function (resolve) {            // 159\n      var absChildId = module.resolve(id);                                   // 160\n      each(module.childrenById, walk);                                       // 161\n      resolve(absChildId);                                                   // 162\n                                                                             // 163\n    }).then(function (absChildId) {                                          // 164\n      // Grab the current missing object and fetch its contents.             // 165\n      var toBeFetched = missing;                                             // 166\n      missing = null;                                                        // 167\n                                                                             // 168\n      return Promise.resolve(                                                // 169\n        // The install.fetch function takes an object mapping missing        // 170\n        // dynamic module identifiers to options objects, and should         // 171\n        // return a Promise that resolves to a module tree that can be       // 172\n        // installed. As an optimization, if there were no missing dynamic   // 173\n        // modules, then we can skip calling install.fetch entirely.         // 174\n        toBeFetched && install.fetch(toBeFetched)                            // 175\n                                                                             // 176\n      ).then(function (tree) {                                               // 177\n        function both() {                                                    // 178\n          install(tree);                                                     // 179\n          return absChildId;                                                 // 180\n        }                                                                    // 181\n                                                                             // 182\n        // Although we want multiple install.fetch calls to run in           // 183\n        // parallel, it is important that the promises returned by           // 184\n        // module.prefetch are resolved in the same order as the original    // 185\n        // calls to module.prefetch, because previous fetches may include    // 186\n        // modules assumed to exist by more recent module.prefetch calls.    // 187\n        // Whether previousPromise was resolved or rejected, carry on with   // 188\n        // the installation regardless.                                      // 189\n        return previousPromise.then(both, both);                             // 190\n      });                                                                    // 191\n    });                                                                      // 192\n  };                                                                         // 193\n                                                                             // 194\n  install.Module = Module;                                                   // 195\n                                                                             // 196\n  function getOwn(obj, key) {                                                // 197\n    return strictHasOwn(obj, key) && obj[key];                               // 198\n  }                                                                          // 199\n                                                                             // 200\n  function isObject(value) {                                                 // 201\n    return value !== null && typeof value === \"object\";                      // 202\n  }                                                                          // 203\n                                                                             // 204\n  function isFunction(value) {                                               // 205\n    return typeof value === \"function\";                                      // 206\n  }                                                                          // 207\n                                                                             // 208\n  function isString(value) {                                                 // 209\n    return typeof value === \"string\";                                        // 210\n  }                                                                          // 211\n                                                                             // 212\n  function makeMissingError(id) {                                            // 213\n    return new Error(\"Cannot find module '\" + id + \"'\");                     // 214\n  }                                                                          // 215\n                                                                             // 216\n  function makeRequire(file) {                                               // 217\n    function require(id) {                                                   // 218\n      var result = fileResolve(file, id);                                    // 219\n      if (result) {                                                          // 220\n        return fileEvaluate(result, file.module);                            // 221\n      }                                                                      // 222\n                                                                             // 223\n      var error = makeMissingError(id);                                      // 224\n                                                                             // 225\n      if (isFunction(fallback)) {                                            // 226\n        return fallback(                                                     // 227\n          id, // The missing module identifier.                              // 228\n          file.module.id, // The path of the requiring file.                 // 229\n          error // The error we would have thrown.                           // 230\n        );                                                                   // 231\n      }                                                                      // 232\n                                                                             // 233\n      throw error;                                                           // 234\n    }                                                                        // 235\n                                                                             // 236\n    if (isFunction(wrapRequire)) {                                           // 237\n      require = wrapRequire(require, file.module);                           // 238\n    }                                                                        // 239\n                                                                             // 240\n    require.extensions = fileGetExtensions(file).slice(0);                   // 241\n                                                                             // 242\n    require.resolve = function (id) {                                        // 243\n      var f = fileResolve(file, id);                                         // 244\n      if (f) return f.module.id;                                             // 245\n      var error = makeMissingError(id);                                      // 246\n      if (fallback && isFunction(fallback.resolve)) {                        // 247\n        return fallback.resolve(id, file.module.id, error);                  // 248\n      }                                                                      // 249\n      throw error;                                                           // 250\n    };                                                                       // 251\n                                                                             // 252\n    return require;                                                          // 253\n  }                                                                          // 254\n                                                                             // 255\n  // File objects represent either directories or modules that have been     // 256\n  // installed. When a `File` respresents a directory, its `.contents`       // 257\n  // property is an object containing the names of the files (or             // 258\n  // directories) that it contains. When a `File` represents a module, its   // 259\n  // `.contents` property is a function that can be invoked with the         // 260\n  // appropriate `(require, exports, module)` arguments to evaluate the      // 261\n  // module. If the `.contents` property is a string, that string will be    // 262\n  // resolved as a module identifier, and the exports of the resulting       // 263\n  // module will provide the exports of the original file. The `.parent`     // 264\n  // property of a File is either a directory `File` or `null`. Note that    // 265\n  // a child may claim another `File` as its parent even if the parent       // 266\n  // does not have an entry for that child in its `.contents` object.        // 267\n  // This is important for implementing anonymous files, and preventing      // 268\n  // child modules from using `../relative/identifier` syntax to examine     // 269\n  // unrelated modules.                                                      // 270\n  function File(moduleId, parent) {                                          // 271\n    var file = this;                                                         // 272\n                                                                             // 273\n    // Link to the parent file.                                              // 274\n    file.parent = parent = parent || null;                                   // 275\n                                                                             // 276\n    // The module object for this File, which will eventually boast an       // 277\n    // .exports property when/if the file is evaluated.                      // 278\n    file.module = new Module(moduleId);                                      // 279\n    filesByModuleId[moduleId] = file;                                        // 280\n                                                                             // 281\n    // The .contents of the file can be either (1) an object, if the file    // 282\n    // represents a directory containing other files; (2) a factory          // 283\n    // function, if the file represents a module that can be imported; (3)   // 284\n    // a string, if the file is an alias for another file; or (4) null, if   // 285\n    // the file's contents are not (yet) available.                          // 286\n    file.contents = null;                                                    // 287\n                                                                             // 288\n    // Set of module identifiers imported by this module. Note that this     // 289\n    // set is not necessarily complete, so don't rely on it unless you       // 290\n    // know what you're doing.                                               // 291\n    file.deps = {};                                                          // 292\n  }                                                                          // 293\n                                                                             // 294\n  function fileEvaluate(file, parentModule) {                                // 295\n    var module = file.module;                                                // 296\n    if (! strictHasOwn(module, \"exports\")) {                                 // 297\n      var contents = file.contents;                                          // 298\n      if (! contents) {                                                      // 299\n        // If this file was installed with array notation, and the array     // 300\n        // contained one or more objects but no functions, then the combined\n        // properties of the objects are treated as a temporary stub for     // 302\n        // file.module.exports. This is particularly important for partial   // 303\n        // package.json modules, so that the resolution logic can know the   // 304\n        // value of the \"main\" and/or \"browser\" fields, at least, even if    // 305\n        // the rest of the package.json file is not (yet) available.         // 306\n        if (file.stub) {                                                     // 307\n          return file.stub;                                                  // 308\n        }                                                                    // 309\n                                                                             // 310\n        throw makeMissingError(module.id);                                   // 311\n      }                                                                      // 312\n                                                                             // 313\n      if (parentModule) {                                                    // 314\n        module.parent = parentModule;                                        // 315\n        var children = parentModule.children;                                // 316\n        if (Array.isArray(children)) {                                       // 317\n          children.push(module);                                             // 318\n        }                                                                    // 319\n      }                                                                      // 320\n                                                                             // 321\n      // If a Module.prototype.useNode method is defined, give it a chance   // 322\n      // to define module.exports based on module.id using Node.             // 323\n      if (! isFunction(module.useNode) ||                                    // 324\n          ! module.useNode()) {                                              // 325\n        contents(                                                            // 326\n          module.require = module.require || makeRequire(file),              // 327\n          // If the file had a .stub, reuse the same object for exports.     // 328\n          module.exports = file.stub || {},                                  // 329\n          module,                                                            // 330\n          file.module.id,                                                    // 331\n          file.parent.module.id                                              // 332\n        );                                                                   // 333\n      }                                                                      // 334\n                                                                             // 335\n      module.loaded = true;                                                  // 336\n    }                                                                        // 337\n                                                                             // 338\n    // The module.runModuleSetters method will be deprecated in favor of     // 339\n    // just module.runSetters: https://github.com/benjamn/reify/pull/160     // 340\n    var runSetters = module.runSetters || module.runModuleSetters;           // 341\n    if (isFunction(runSetters)) {                                            // 342\n      runSetters.call(module);                                               // 343\n    }                                                                        // 344\n                                                                             // 345\n    return module.exports;                                                   // 346\n  }                                                                          // 347\n                                                                             // 348\n  function fileIsDirectory(file) {                                           // 349\n    return file && isObject(file.contents);                                  // 350\n  }                                                                          // 351\n                                                                             // 352\n  function fileIsDynamic(file) {                                             // 353\n    return file && file.contents === null;                                   // 354\n  }                                                                          // 355\n                                                                             // 356\n  function fileMergeContents(file, contents, options) {                      // 357\n    if (Array.isArray(contents)) {                                           // 358\n      contents.forEach(function (item) {                                     // 359\n        if (isString(item)) {                                                // 360\n          file.deps[item] = file.module.id;                                  // 361\n        } else if (isFunction(item)) {                                       // 362\n          contents = item;                                                   // 363\n        } else if (isObject(item)) {                                         // 364\n          file.stub = file.stub || {};                                       // 365\n          each(item, function (value, key) {                                 // 366\n            file.stub[key] = value;                                          // 367\n          });                                                                // 368\n        }                                                                    // 369\n      });                                                                    // 370\n                                                                             // 371\n      if (! isFunction(contents)) {                                          // 372\n        // If the array did not contain a function, merge nothing.           // 373\n        contents = null;                                                     // 374\n      }                                                                      // 375\n                                                                             // 376\n    } else if (! isFunction(contents) &&                                     // 377\n               ! isString(contents) &&                                       // 378\n               ! isObject(contents)) {                                       // 379\n      // If contents is neither an array nor a function nor a string nor     // 380\n      // an object, just give up and merge nothing.                          // 381\n      contents = null;                                                       // 382\n    }                                                                        // 383\n                                                                             // 384\n    if (contents) {                                                          // 385\n      file.contents = file.contents || (isObject(contents) ? {} : contents);\n      if (isObject(contents) && fileIsDirectory(file)) {                     // 387\n        each(contents, function (value, key) {                               // 388\n          if (key === \"..\") {                                                // 389\n            child = file.parent;                                             // 390\n                                                                             // 391\n          } else {                                                           // 392\n            var child = getOwn(file.contents, key);                          // 393\n                                                                             // 394\n            if (! child) {                                                   // 395\n              child = file.contents[key] = new File(                         // 396\n                file.module.id.replace(/\\/*$/, \"/\") + key,                   // 397\n                file                                                         // 398\n              );                                                             // 399\n                                                                             // 400\n              child.options = options;                                       // 401\n            }                                                                // 402\n          }                                                                  // 403\n                                                                             // 404\n          fileMergeContents(child, value, options);                          // 405\n        });                                                                  // 406\n      }                                                                      // 407\n    }                                                                        // 408\n  }                                                                          // 409\n                                                                             // 410\n  function each(obj, callback, context) {                                    // 411\n    Object.keys(obj).forEach(function (key) {                                // 412\n      callback.call(this, obj[key], key);                                    // 413\n    }, context);                                                             // 414\n  }                                                                          // 415\n                                                                             // 416\n  function fileGetExtensions(file) {                                         // 417\n    return file.options                                                      // 418\n      && file.options.extensions                                             // 419\n      || defaultExtensions;                                                  // 420\n  }                                                                          // 421\n                                                                             // 422\n  function fileAppendIdPart(file, part, extensions) {                        // 423\n    // Always append relative to a directory.                                // 424\n    while (file && ! fileIsDirectory(file)) {                                // 425\n      file = file.parent;                                                    // 426\n    }                                                                        // 427\n                                                                             // 428\n    if (! file || ! part || part === \".\") {                                  // 429\n      return file;                                                           // 430\n    }                                                                        // 431\n                                                                             // 432\n    if (part === \"..\") {                                                     // 433\n      return file.parent;                                                    // 434\n    }                                                                        // 435\n                                                                             // 436\n    var exactChild = getOwn(file.contents, part);                            // 437\n                                                                             // 438\n    // Only consider multiple file extensions if this part is the last       // 439\n    // part of a module identifier and not equal to `.` or `..`, and there   // 440\n    // was no exact match or the exact match was a directory.                // 441\n    if (extensions && (! exactChild || fileIsDirectory(exactChild))) {       // 442\n      for (var e = 0; e < extensions.length; ++e) {                          // 443\n        var child = getOwn(file.contents, part + extensions[e]);             // 444\n        if (child && ! fileIsDirectory(child)) {                             // 445\n          return child;                                                      // 446\n        }                                                                    // 447\n      }                                                                      // 448\n    }                                                                        // 449\n                                                                             // 450\n    return exactChild;                                                       // 451\n  }                                                                          // 452\n                                                                             // 453\n  function fileAppendId(file, id, extensions) {                              // 454\n    var parts = id.split(\"/\");                                               // 455\n                                                                             // 456\n    // Use `Array.prototype.every` to terminate iteration early if           // 457\n    // `fileAppendIdPart` returns a falsy value.                             // 458\n    parts.every(function (part, i) {                                         // 459\n      return file = i < parts.length - 1                                     // 460\n        ? fileAppendIdPart(file, part)                                       // 461\n        : fileAppendIdPart(file, part, extensions);                          // 462\n    });                                                                      // 463\n                                                                             // 464\n    return file;                                                             // 465\n  }                                                                          // 466\n                                                                             // 467\n  function recordChild(parentModule, childFile) {                            // 468\n    var childModule = childFile && childFile.module;                         // 469\n    if (parentModule && childModule) {                                       // 470\n      parentModule.childrenById[childModule.id] = childModule;               // 471\n    }                                                                        // 472\n  }                                                                          // 473\n                                                                             // 474\n  function fileResolve(file, id, parentModule, seenDirFiles) {               // 475\n    var parentModule = parentModule || file.module;                          // 476\n    var extensions = fileGetExtensions(file);                                // 477\n                                                                             // 478\n    file =                                                                   // 479\n      // Absolute module identifiers (i.e. those that begin with a `/`       // 480\n      // character) are interpreted relative to the root directory, which    // 481\n      // is a slight deviation from Node, which has access to the entire     // 482\n      // file system.                                                        // 483\n      id.charAt(0) === \"/\" ? fileAppendId(root, id, extensions) :            // 484\n      // Relative module identifiers are interpreted relative to the         // 485\n      // current file, naturally.                                            // 486\n      id.charAt(0) === \".\" ? fileAppendId(file, id, extensions) :            // 487\n      // Top-level module identifiers are interpreted as referring to        // 488\n      // packages in `node_modules` directories.                             // 489\n      nodeModulesLookup(file, id, extensions);                               // 490\n                                                                             // 491\n    // If the identifier resolves to a directory, we use the same logic as   // 492\n    // Node to find an `index.js` or `package.json` file to evaluate.        // 493\n    while (fileIsDirectory(file)) {                                          // 494\n      seenDirFiles = seenDirFiles || [];                                     // 495\n                                                                             // 496\n      // If the \"main\" field of a `package.json` file resolves to a          // 497\n      // directory we've already considered, then we should not attempt to   // 498\n      // read the same `package.json` file again. Using an array as a set    // 499\n      // is acceptable here because the number of directories to consider    // 500\n      // is rarely greater than 1 or 2. Also, using indexOf allows us to     // 501\n      // store File objects instead of strings.                              // 502\n      if (seenDirFiles.indexOf(file) < 0) {                                  // 503\n        seenDirFiles.push(file);                                             // 504\n                                                                             // 505\n        var pkgJsonFile = fileAppendIdPart(file, \"package.json\"), main;      // 506\n        var pkg = pkgJsonFile && fileEvaluate(pkgJsonFile, parentModule);    // 507\n        if (pkg &&                                                           // 508\n            mainFields.some(function (name) {                                // 509\n              return isString(main = pkg[name]);                             // 510\n            })) {                                                            // 511\n          recordChild(parentModule, pkgJsonFile);                            // 512\n                                                                             // 513\n          // The \"main\" field of package.json does not have to begin with    // 514\n          // ./ to be considered relative, so first we try simply            // 515\n          // appending it to the directory path before falling back to a     // 516\n          // full fileResolve, which might return a package from a           // 517\n          // node_modules directory.                                         // 518\n          file = fileAppendId(file, main, extensions) ||                     // 519\n            fileResolve(file, main, parentModule, seenDirFiles);             // 520\n                                                                             // 521\n          if (file) {                                                        // 522\n            // The fileAppendId call above may have returned a directory,    // 523\n            // so continue the loop to make sure we resolve it to a          // 524\n            // non-directory file.                                           // 525\n            continue;                                                        // 526\n          }                                                                  // 527\n        }                                                                    // 528\n      }                                                                      // 529\n                                                                             // 530\n      // If we didn't find a `package.json` file, or it didn't have a        // 531\n      // resolvable `.main` property, the only possibility left to           // 532\n      // consider is that this directory contains an `index.js` module.      // 533\n      // This assignment almost always terminates the while loop, because    // 534\n      // there's very little chance `fileIsDirectory(file)` will be true     // 535\n      // for the result of `fileAppendIdPart(file, \"index.js\")`. However,    // 536\n      // in principle it is remotely possible that a file called             // 537\n      // `index.js` could be a directory instead of a file.                  // 538\n      file = fileAppendIdPart(file, \"index.js\");                             // 539\n    }                                                                        // 540\n                                                                             // 541\n    if (file && isString(file.contents)) {                                   // 542\n      file = fileResolve(file, file.contents, parentModule, seenDirFiles);   // 543\n    }                                                                        // 544\n                                                                             // 545\n    recordChild(parentModule, file);                                         // 546\n                                                                             // 547\n    return file;                                                             // 548\n  };                                                                         // 549\n                                                                             // 550\n  function nodeModulesLookup(file, id, extensions) {                         // 551\n    if (isFunction(override)) {                                              // 552\n      id = override(id, file.module.id);                                     // 553\n    }                                                                        // 554\n                                                                             // 555\n    if (isString(id)) {                                                      // 556\n      for (var resolved; file && ! resolved; file = file.parent) {           // 557\n        resolved = fileIsDirectory(file) &&                                  // 558\n          fileAppendId(file, \"node_modules/\" + id, extensions);              // 559\n      }                                                                      // 560\n                                                                             // 561\n      return resolved;                                                       // 562\n    }                                                                        // 563\n  }                                                                          // 564\n                                                                             // 565\n  return install;                                                            // 566\n};                                                                           // 567\n                                                                             // 568\nif (typeof exports === \"object\") {                                           // 569\n  exports.makeInstaller = makeInstaller;                                     // 570\n}                                                                            // 571\n                                                                             // 572\n///////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/options.js                                       //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\nmakeInstallerOptions = {};                                                   // 1\n                                                                             // 2\nif (typeof Profile === \"function\" &&                                         // 3\n    process.env.METEOR_PROFILE) {                                            // 4\n  makeInstallerOptions.wrapRequire = function (require) {                    // 5\n    return Profile(function (id) {                                           // 6\n      return \"require(\" + JSON.stringify(id) + \")\";                          // 7\n    }, require);                                                             // 8\n  };                                                                         // 9\n}                                                                            // 10\n                                                                             // 11\n///////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////\n//                                                                           //\n// packages/modules-runtime/client.js                                        //\n//                                                                           //\n///////////////////////////////////////////////////////////////////////////////\n                                                                             //\n// On the client, make package resolution prefer the \"browser\" field of      // 1\n// package.json files to the \"main\" field.                                   // 2\nmakeInstallerOptions.browser = true;                                         // 3\n                                                                             // 4\nmeteorInstall = makeInstaller(makeInstallerOptions);                         // 5\n                                                                             // 6\n///////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['modules-runtime'] = {}, {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules-runtime.js"}]
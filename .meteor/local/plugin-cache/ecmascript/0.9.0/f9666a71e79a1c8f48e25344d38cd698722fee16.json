{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/mdg:validated-method/validated-method-tests.js","filenameRelative":"packages/mdg:validated-method/validated-method-tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/mdg:validated-method/validated-method-tests.js.map","sourceFileName":"packages/mdg:validated-method/validated-method-tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"validated-method-tests"},"ignored":false,"code":"const plainMethod = new ValidatedMethod({\n  name: 'plainMethod',\n  validate: new SimpleSchema({}).validator(),\n\n  run() {\n    return 'result';\n  }\n\n});\nconst noArgsMethod = new ValidatedMethod({\n  name: 'noArgsMethod',\n  validate: null,\n\n  run() {\n    return 'result';\n  }\n\n});\nconst methodWithArgs = new ValidatedMethod({\n  name: 'methodWithArgs',\n  validate: new SimpleSchema({\n    int: {\n      type: Number\n    },\n    string: {\n      type: String\n    }\n  }).validator(),\n\n  run() {\n    return 'result';\n  }\n\n});\nconst methodThrowsImmediately = new ValidatedMethod({\n  name: 'methodThrowsImmediately',\n  validate: null,\n\n  run() {\n    throw new Meteor.Error('error');\n  }\n\n});\nconst methodReturnsName = new ValidatedMethod({\n  name: 'methodReturnsName',\n  validate: null,\n\n  run() {\n    return this.name;\n  }\n\n});\nconst methodWithSchemaMixin = new ValidatedMethod({\n  name: 'methodWithSchemaMixin',\n  mixins: [schemaMixin],\n  schema: new SimpleSchema({\n    int: {\n      type: Number\n    },\n    string: {\n      type: String\n    }\n  }),\n\n  run() {\n    return 'result';\n  }\n\n});\nlet resultReceived = false;\nconst methodWithApplyOptions = new ValidatedMethod({\n  name: 'methodWithApplyOptions',\n  validate: new SimpleSchema({}).validator(),\n  applyOptions: {\n    onResultReceived: function () {\n      resultReceived = true;\n    }\n  },\n\n  run() {\n    return 'result';\n  }\n\n});\n\nfunction schemaMixin(methodOptions) {\n  methodOptions.validate = methodOptions.schema.validator();\n  return methodOptions;\n}\n\ndescribe('mdg:method', () => {\n  it('defines a method that can be called', done => {\n    plainMethod.call({}, (error, result) => {\n      assert.equal(result, 'result');\n      Meteor.call(plainMethod.name, {}, (error, result) => {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n  it('allows methods that take no arguments', done => {\n    noArgsMethod.call((error, result) => {\n      assert.equal(result, 'result');\n      Meteor.call(noArgsMethod.name, (error, result) => {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n  it('checks schema', done => {\n    [methodWithArgs, methodWithSchemaMixin].forEach(method => {\n      method.call({}, (error, result) => {\n        // 2 invalid fields\n        assert.equal(error.errors.length, 2);\n        method.call({\n          int: 5,\n          string: \"what\"\n        }, (error, result) => {\n          // All good!\n          assert.equal(result, 'result');\n          done();\n        });\n      });\n    });\n  });\n  it('throws error if no callback passed', done => {\n    methodThrowsImmediately.call({}, err => {\n      // If you pass a callback, you get the error in the callback\n      assert.ok(err); // If no callback, the error is thrown\n\n      assert.throws(() => {\n        methodThrowsImmediately.call({});\n      }, /error/);\n      done();\n    });\n  });\n  it('throws error if a mixin does not return the options object', () => {\n    assert.throws(() => {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function nonReturningFunction() {}],\n        schema: null,\n\n        run() {\n          return 'result';\n        }\n\n      });\n    }, /Error in methodWithFaultySchemaMixin method: The function 'nonReturningFunction' didn't return the options object/);\n    assert.throws(() => {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function (args) {\n          return args;\n        }, function () {}],\n        schema: null,\n\n        run() {\n          return 'result';\n        }\n\n      });\n    }, /Error in methodWithFaultySchemaMixin method: One of the mixins didn't return the options object/);\n  });\n  it('has access to the name on this.name', done => {\n    const ret = methodReturnsName._execute();\n\n    assert.equal(ret, 'methodReturnsName');\n    methodReturnsName.call({}, (err, res) => {\n      // The Method knows its own name\n      assert.equal(res, 'methodReturnsName');\n      done();\n    });\n  });\n  it('can accept Meteor.apply options', done => {\n    if (Meteor.isServer) {\n      // the only apply option that I can think of to test is client side only\n      return done();\n    }\n\n    resultReceived = false;\n    methodWithApplyOptions.call({}, (err, res) => {\n      // The Method knows its own name\n      assert.equal(resultReceived, true);\n      done();\n    });\n  });\n});","map":{"version":3,"sources":["packages/mdg:validated-method/validated-method-tests.js"],"names":["plainMethod","ValidatedMethod","name","validate","SimpleSchema","validator","run","noArgsMethod","methodWithArgs","int","type","Number","string","String","methodThrowsImmediately","Meteor","Error","methodReturnsName","methodWithSchemaMixin","mixins","schemaMixin","schema","resultReceived","methodWithApplyOptions","applyOptions","onResultReceived","methodOptions","describe","it","done","call","error","result","assert","equal","forEach","method","errors","length","err","ok","throws","nonReturningFunction","args","ret","_execute","res","isServer"],"mappings":"AAAA,MAAMA,cAAc,IAAIC,eAAJ,CAAoB;AACtCC,QAAM,aADgC;AAEtCC,YAAU,IAAIC,YAAJ,CAAiB,EAAjB,EAAqBC,SAArB,EAF4B;;AAGtCC,QAAM;AACJ,WAAO,QAAP;AACD;;AALqC,CAApB,CAApB;AAQA,MAAMC,eAAe,IAAIN,eAAJ,CAAoB;AACvCC,QAAM,cADiC;AAEvCC,YAAU,IAF6B;;AAGvCG,QAAM;AACJ,WAAO,QAAP;AACD;;AALsC,CAApB,CAArB;AAQA,MAAME,iBAAiB,IAAIP,eAAJ,CAAoB;AACzCC,QAAM,gBADmC;AAEzCC,YAAU,IAAIC,YAAJ,CAAiB;AACzBK,SAAK;AAAEC,YAAMC;AAAR,KADoB;AAEzBC,YAAQ;AAAEF,YAAMG;AAAR;AAFiB,GAAjB,EAGPR,SAHO,EAF+B;;AAMzCC,QAAM;AACJ,WAAO,QAAP;AACD;;AARwC,CAApB,CAAvB;AAWA,MAAMQ,0BAA0B,IAAIb,eAAJ,CAAoB;AAClDC,QAAM,yBAD4C;AAElDC,YAAU,IAFwC;;AAGlDG,QAAM;AACJ,UAAM,IAAIS,OAAOC,KAAX,CAAiB,OAAjB,CAAN;AACD;;AALiD,CAApB,CAAhC;AAQA,MAAMC,oBAAoB,IAAIhB,eAAJ,CAAoB;AAC5CC,QAAM,mBADsC;AAE5CC,YAAU,IAFkC;;AAG5CG,QAAM;AACJ,WAAO,KAAKJ,IAAZ;AACD;;AAL2C,CAApB,CAA1B;AAQA,MAAMgB,wBAAwB,IAAIjB,eAAJ,CAAoB;AAChDC,QAAM,uBAD0C;AAEhDiB,UAAQ,CAACC,WAAD,CAFwC;AAGhDC,UAAQ,IAAIjB,YAAJ,CAAiB;AACvBK,SAAK;AAAEC,YAAMC;AAAR,KADkB;AAEvBC,YAAQ;AAAEF,YAAMG;AAAR;AAFe,GAAjB,CAHwC;;AAOhDP,QAAM;AACJ,WAAO,QAAP;AACD;;AAT+C,CAApB,CAA9B;AAYA,IAAIgB,iBAAiB,KAArB;AACA,MAAMC,yBAAyB,IAAItB,eAAJ,CAAoB;AACjDC,QAAM,wBAD2C;AAEjDC,YAAU,IAAIC,YAAJ,CAAiB,EAAjB,EAAqBC,SAArB,EAFuC;AAGjDmB,gBAAc;AACZC,sBAAkB,YAAW;AAC3BH,uBAAiB,IAAjB;AACD;AAHW,GAHmC;;AAQjDhB,QAAM;AACJ,WAAO,QAAP;AACD;;AAVgD,CAApB,CAA/B;;AAaA,SAASc,WAAT,CAAqBM,aAArB,EAAoC;AAClCA,gBAAcvB,QAAd,GAAyBuB,cAAcL,MAAd,CAAqBhB,SAArB,EAAzB;AACA,SAAOqB,aAAP;AACD;;AAEDC,SAAS,YAAT,EAAuB,MAAM;AAC3BC,KAAG,qCAAH,EAA2CC,IAAD,IAAU;AAClD7B,gBAAY8B,IAAZ,CAAiB,EAAjB,EAAqB,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACtCC,aAAOC,KAAP,CAAaF,MAAb,EAAqB,QAArB;AAEAjB,aAAOe,IAAP,CAAY9B,YAAYE,IAAxB,EAA8B,EAA9B,EAAkC,CAAC6B,KAAD,EAAQC,MAAR,KAAmB;AACnDC,eAAOC,KAAP,CAAaF,MAAb,EAAqB,QAArB;AACAH;AACD,OAHD;AAID,KAPD;AAQD,GATD;AAWAD,KAAG,uCAAH,EAA6CC,IAAD,IAAU;AACpDtB,iBAAauB,IAAb,CAAkB,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACnCC,aAAOC,KAAP,CAAaF,MAAb,EAAqB,QAArB;AAEAjB,aAAOe,IAAP,CAAYvB,aAAaL,IAAzB,EAA+B,CAAC6B,KAAD,EAAQC,MAAR,KAAmB;AAChDC,eAAOC,KAAP,CAAaF,MAAb,EAAqB,QAArB;AACAH;AACD,OAHD;AAID,KAPD;AAQD,GATD;AAWAD,KAAG,eAAH,EAAqBC,IAAD,IAAU;AAC5B,KAACrB,cAAD,EAAiBU,qBAAjB,EAAwCiB,OAAxC,CAAiDC,MAAD,IAAY;AAC1DA,aAAON,IAAP,CAAY,EAAZ,EAAgB,CAACC,KAAD,EAAQC,MAAR,KAAmB;AACjC;AACAC,eAAOC,KAAP,CAAaH,MAAMM,MAAN,CAAaC,MAA1B,EAAkC,CAAlC;AAEAF,eAAON,IAAP,CAAY;AACVrB,eAAK,CADK;AAEVG,kBAAQ;AAFE,SAAZ,EAGG,CAACmB,KAAD,EAAQC,MAAR,KAAmB;AACpB;AACAC,iBAAOC,KAAP,CAAaF,MAAb,EAAqB,QAArB;AAEAH;AACD,SARD;AASD,OAbD;AAcD,KAfD;AAgBD,GAjBD;AAmBAD,KAAG,oCAAH,EAA0CC,IAAD,IAAU;AACjDf,4BAAwBgB,IAAxB,CAA6B,EAA7B,EAAkCS,GAAD,IAAS;AACxC;AACAN,aAAOO,EAAP,CAAUD,GAAV,EAFwC,CAIxC;;AACAN,aAAOQ,MAAP,CAAc,MAAM;AAClB3B,gCAAwBgB,IAAxB,CAA6B,EAA7B;AACD,OAFD,EAEG,OAFH;AAIAD;AACD,KAVD;AAWD,GAZD;AAcAD,KAAG,4DAAH,EAAiE,MAAM;AACrEK,WAAOQ,MAAP,CAAc,MAAM;AAClB,UAAIxC,eAAJ,CAAoB;AAClBC,cAAM,6BADY;AAElBiB,gBAAQ,CAAC,SAASuB,oBAAT,GAAgC,CAAE,CAAnC,CAFU;AAGlBrB,gBAAQ,IAHU;;AAIlBf,cAAM;AACJ,iBAAO,QAAP;AACD;;AANiB,OAApB;AAQD,KATD,EASG,mHATH;AAWA2B,WAAOQ,MAAP,CAAc,MAAM;AAClB,UAAIxC,eAAJ,CAAoB;AAClBC,cAAM,6BADY;AAElBiB,gBAAQ,CAAC,UAAUwB,IAAV,EAAgB;AAAE,iBAAOA,IAAP;AAAY,SAA/B,EAAiC,YAAY,CAAE,CAA/C,CAFU;AAGlBtB,gBAAQ,IAHU;;AAIlBf,cAAM;AACJ,iBAAO,QAAP;AACD;;AANiB,OAApB;AAQD,KATD,EASG,iGATH;AAUD,GAtBD;AAwBAsB,KAAG,qCAAH,EAA2CC,IAAD,IAAU;AAClD,UAAMe,MAAM3B,kBAAkB4B,QAAlB,EAAZ;;AACAZ,WAAOC,KAAP,CAAaU,GAAb,EAAkB,mBAAlB;AAEA3B,sBAAkBa,IAAlB,CAAuB,EAAvB,EAA2B,CAACS,GAAD,EAAMO,GAAN,KAAc;AACvC;AACAb,aAAOC,KAAP,CAAaY,GAAb,EAAkB,mBAAlB;AAEAjB;AACD,KALD;AAMD,GAVD;AAYAD,KAAG,iCAAH,EAAuCC,IAAD,IAAU;AAC9C,QAAId,OAAOgC,QAAX,EAAqB;AACnB;AACA,aAAOlB,MAAP;AACD;;AAEDP,qBAAiB,KAAjB;AACAC,2BAAuBO,IAAvB,CAA4B,EAA5B,EAAgC,CAACS,GAAD,EAAMO,GAAN,KAAc;AAC5C;AACAb,aAAOC,KAAP,CAAaZ,cAAb,EAA6B,IAA7B;AAEAO;AACD,KALD;AAMD,GAbD;AAcD,CA1GD","file":"packages/mdg:validated-method/validated-method-tests.js.map","sourcesContent":["const plainMethod = new ValidatedMethod({\n  name: 'plainMethod',\n  validate: new SimpleSchema({}).validator(),\n  run() {\n    return 'result';\n  }\n});\n\nconst noArgsMethod = new ValidatedMethod({\n  name: 'noArgsMethod',\n  validate: null,\n  run() {\n    return 'result';\n  }\n});\n\nconst methodWithArgs = new ValidatedMethod({\n  name: 'methodWithArgs',\n  validate: new SimpleSchema({\n    int: { type: Number },\n    string: { type: String },\n  }).validator(),\n  run() {\n    return 'result';\n  }\n});\n\nconst methodThrowsImmediately = new ValidatedMethod({\n  name: 'methodThrowsImmediately',\n  validate: null,\n  run() {\n    throw new Meteor.Error('error');\n  }\n});\n\nconst methodReturnsName = new ValidatedMethod({\n  name: 'methodReturnsName',\n  validate: null,\n  run() {\n    return this.name;\n  }\n});\n\nconst methodWithSchemaMixin = new ValidatedMethod({\n  name: 'methodWithSchemaMixin',\n  mixins: [schemaMixin],\n  schema: new SimpleSchema({\n    int: { type: Number },\n    string: { type: String },\n  }),\n  run() {\n    return 'result';\n  }\n});\n\nlet resultReceived = false;\nconst methodWithApplyOptions = new ValidatedMethod({\n  name: 'methodWithApplyOptions',\n  validate: new SimpleSchema({}).validator(),\n  applyOptions: {\n    onResultReceived: function() {\n      resultReceived = true;\n    }\n  },\n  run() {\n    return 'result';\n  }\n});\n\nfunction schemaMixin(methodOptions) {\n  methodOptions.validate = methodOptions.schema.validator();\n  return methodOptions;\n}\n\ndescribe('mdg:method', () => {\n  it('defines a method that can be called', (done) => {\n    plainMethod.call({}, (error, result) => {\n      assert.equal(result, 'result');\n\n      Meteor.call(plainMethod.name, {}, (error, result) => {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n\n  it('allows methods that take no arguments', (done) => {\n    noArgsMethod.call((error, result) => {\n      assert.equal(result, 'result');\n\n      Meteor.call(noArgsMethod.name, (error, result) => {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n\n  it('checks schema', (done) => {\n    [methodWithArgs, methodWithSchemaMixin].forEach((method) => {\n      method.call({}, (error, result) => {\n        // 2 invalid fields\n        assert.equal(error.errors.length, 2);\n\n        method.call({\n          int: 5,\n          string: \"what\",\n        }, (error, result) => {\n          // All good!\n          assert.equal(result, 'result');\n\n          done();\n        });\n      });\n    });\n  });\n\n  it('throws error if no callback passed', (done) => {\n    methodThrowsImmediately.call({}, (err) => {\n      // If you pass a callback, you get the error in the callback\n      assert.ok(err);\n\n      // If no callback, the error is thrown\n      assert.throws(() => {\n        methodThrowsImmediately.call({});\n      }, /error/);\n\n      done();\n    });\n  });\n\n  it('throws error if a mixin does not return the options object', () => {\n    assert.throws(() => {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function nonReturningFunction() {}],\n        schema: null,\n        run() {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: The function 'nonReturningFunction' didn't return the options object/);\n\n    assert.throws(() => {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function (args) { return args}, function () {}],\n        schema: null,\n        run() {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: One of the mixins didn't return the options object/);\n  });\n\n  it('has access to the name on this.name', (done) => {\n    const ret = methodReturnsName._execute();\n    assert.equal(ret, 'methodReturnsName');\n\n    methodReturnsName.call({}, (err, res) => {\n      // The Method knows its own name\n      assert.equal(res, 'methodReturnsName');\n\n      done();\n    });\n  });\n\n  it('can accept Meteor.apply options', (done) => {\n    if (Meteor.isServer) {\n      // the only apply option that I can think of to test is client side only\n      return done();\n    }\n\n    resultReceived = false;\n    methodWithApplyOptions.call({}, (err, res) => {\n      // The Method knows its own name\n      assert.equal(resultReceived, true);\n\n      done();\n    });\n  });\n});\n"]},"hash":"f9666a71e79a1c8f48e25344d38cd698722fee16"}

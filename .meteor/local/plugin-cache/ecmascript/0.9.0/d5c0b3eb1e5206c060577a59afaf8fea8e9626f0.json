{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/dynamic-import/client.js","filenameRelative":"packages/dynamic-import/client.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/dynamic-import/client.js.map","sourceFileName":"packages/dynamic-import/client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"client"},"ignored":false,"code":"var Module = module.constructor;\n\nvar cache = require(\"./cache.js\"); // Call module.dynamicImport(id) to fetch a module and any/all of its\n// dependencies that have not already been fetched, and evaluate them as\n// soon as they arrive. This runtime API makes it very easy to implement\n// ECMAScript dynamic import(...) syntax.\n\n\nModule.prototype.dynamicImport = function (id) {\n  var module = this;\n  return module.prefetch(id).then(function () {\n    return getNamespace(module, id);\n  });\n}; // Called by Module.prototype.prefetch if there are any missing dynamic\n// modules that need to be fetched.\n\n\nmeteorInstall.fetch = function (ids) {\n  var tree = Object.create(null);\n  var versions = Object.create(null);\n\n  var dynamicVersions = require(\"./dynamic-versions.js\");\n\n  var missing;\n\n  function addSource(id, source) {\n    addToTree(tree, id, makeModuleFunction(id, source, ids[id].options));\n  }\n\n  function addMissing(id) {\n    addToTree(missing = missing || Object.create(null), id, 1);\n  }\n\n  Object.keys(ids).forEach(function (id) {\n    var version = dynamicVersions.get(id);\n\n    if (version) {\n      versions[id] = version;\n    } else {\n      addMissing(id);\n    }\n  });\n  return cache.checkMany(versions).then(function (sources) {\n    Object.keys(sources).forEach(function (id) {\n      var source = sources[id];\n\n      if (source) {\n        addSource(id, source);\n      } else {\n        addMissing(id);\n      }\n    });\n    return missing && fetchMissing(missing).then(function (results) {\n      var versionsAndSourcesById = Object.create(null);\n      var flatResults = flattenModuleTree(results);\n      Object.keys(flatResults).forEach(function (id) {\n        var source = flatResults[id];\n        addSource(id, source);\n        var version = dynamicVersions.get(id);\n\n        if (version) {\n          versionsAndSourcesById[id] = {\n            version: version,\n            source: source\n          };\n        }\n      });\n      cache.setMany(versionsAndSourcesById);\n    });\n  }).then(function () {\n    return tree;\n  });\n};\n\nfunction flattenModuleTree(tree) {\n  var parts = [\"\"];\n  var result = Object.create(null);\n\n  function walk(t) {\n    if (t && typeof t === \"object\") {\n      Object.keys(t).forEach(function (key) {\n        parts.push(key);\n        walk(t[key]);\n        parts.pop();\n      });\n    } else if (typeof t === \"string\") {\n      result[parts.join(\"/\")] = t;\n    }\n  }\n\n  walk(tree);\n  return result;\n}\n\nfunction makeModuleFunction(id, source, options) {\n  // By calling (options && options.eval || eval) in a wrapper function,\n  // we delay the cost of parsing and evaluating the module code until the\n  // module is first imported.\n  return function () {\n    // If an options.eval function was provided in the second argument to\n    // meteorInstall when this bundle was first installed, use that\n    // function to parse and evaluate the dynamic module code in the scope\n    // of the package. Otherwise fall back to indirect (global) eval.\n    return (options && options.eval || eval)( // Wrap the function(require,exports,module){...} expression in\n    // parentheses to force it to be parsed as an expression.\n    \"(\" + source + \")\\n//# sourceURL=\" + id).apply(this, arguments);\n  };\n}\n\nfunction fetchMissing(missingTree) {\n  // Update lastFetchMissingPromise immediately, without waiting for\n  // the results to be delivered.\n  return new Promise(function (resolve, reject) {\n    Meteor.call(\"__dynamicImport\", missingTree, function (error, resultsTree) {\n      error ? reject(error) : resolve(resultsTree);\n    });\n  });\n}\n\nfunction addToTree(tree, id, value) {\n  var parts = id.split(\"/\");\n  var lastIndex = parts.length - 1;\n  parts.forEach(function (part, i) {\n    if (part) {\n      tree = tree[part] = tree[part] || (i < lastIndex ? Object.create(null) : value);\n    }\n  });\n}\n\nfunction getNamespace(module, id) {\n  var namespace;\n  module.watch(module.require(id), {\n    \"*\": function (ns) {\n      namespace = ns;\n    }\n  }); // This helps with Babel interop, since we're not just returning the\n  // module.exports object.\n\n  Object.defineProperty(namespace, \"__esModule\", {\n    value: true,\n    enumerable: false\n  });\n  return namespace;\n}","map":{"version":3,"sources":["packages/dynamic-import/client.js"],"names":["Module","module","constructor","cache","require","prototype","dynamicImport","id","prefetch","then","getNamespace","meteorInstall","fetch","ids","tree","Object","create","versions","dynamicVersions","missing","addSource","source","addToTree","makeModuleFunction","options","addMissing","keys","forEach","version","get","checkMany","sources","fetchMissing","results","versionsAndSourcesById","flatResults","flattenModuleTree","setMany","parts","result","walk","t","key","push","pop","join","eval","apply","arguments","missingTree","Promise","resolve","reject","Meteor","call","error","resultsTree","value","split","lastIndex","length","part","i","namespace","watch","ns","defineProperty","enumerable"],"mappings":"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","file":"packages/dynamic-import/client.js.map","sourcesContent":["var Module = module.constructor;\nvar cache = require(\"./cache.js\");\n\n// Call module.dynamicImport(id) to fetch a module and any/all of its\n// dependencies that have not already been fetched, and evaluate them as\n// soon as they arrive. This runtime API makes it very easy to implement\n// ECMAScript dynamic import(...) syntax.\nModule.prototype.dynamicImport = function (id) {\n  var module = this;\n  return module.prefetch(id).then(function () {\n    return getNamespace(module, id);\n  });\n};\n\n// Called by Module.prototype.prefetch if there are any missing dynamic\n// modules that need to be fetched.\nmeteorInstall.fetch = function (ids) {\n  var tree = Object.create(null);\n  var versions = Object.create(null);\n  var dynamicVersions = require(\"./dynamic-versions.js\");\n  var missing;\n\n  function addSource(id, source) {\n    addToTree(tree, id, makeModuleFunction(id, source, ids[id].options));\n  }\n\n  function addMissing(id) {\n    addToTree(missing = missing || Object.create(null), id, 1);\n  }\n\n  Object.keys(ids).forEach(function (id) {\n    var version = dynamicVersions.get(id);\n    if (version) {\n      versions[id] = version;\n    } else {\n      addMissing(id);\n    }\n  });\n\n  return cache.checkMany(versions).then(function (sources) {\n    Object.keys(sources).forEach(function (id) {\n      var source = sources[id];\n      if (source) {\n        addSource(id, source);\n      } else {\n        addMissing(id);\n      }\n    });\n\n    return missing && fetchMissing(missing).then(function (results) {\n      var versionsAndSourcesById = Object.create(null);\n      var flatResults = flattenModuleTree(results);\n\n      Object.keys(flatResults).forEach(function (id) {\n        var source = flatResults[id];\n        addSource(id, source);\n\n        var version = dynamicVersions.get(id);\n        if (version) {\n          versionsAndSourcesById[id] = {\n            version: version,\n            source: source\n          };\n        }\n      });\n\n      cache.setMany(versionsAndSourcesById);\n    });\n\n  }).then(function () {\n    return tree;\n  });\n};\n\nfunction flattenModuleTree(tree) {\n  var parts = [\"\"];\n  var result = Object.create(null);\n\n  function walk(t) {\n    if (t && typeof t === \"object\") {\n      Object.keys(t).forEach(function (key) {\n        parts.push(key);\n        walk(t[key]);\n        parts.pop();\n      });\n    } else if (typeof t === \"string\") {\n      result[parts.join(\"/\")] = t;\n    }\n  }\n\n  walk(tree);\n\n  return result;\n}\n\nfunction makeModuleFunction(id, source, options) {\n  // By calling (options && options.eval || eval) in a wrapper function,\n  // we delay the cost of parsing and evaluating the module code until the\n  // module is first imported.\n  return function () {\n    // If an options.eval function was provided in the second argument to\n    // meteorInstall when this bundle was first installed, use that\n    // function to parse and evaluate the dynamic module code in the scope\n    // of the package. Otherwise fall back to indirect (global) eval.\n    return (options && options.eval || eval)(\n      // Wrap the function(require,exports,module){...} expression in\n      // parentheses to force it to be parsed as an expression.\n      \"(\" + source + \")\\n//# sourceURL=\" + id\n    ).apply(this, arguments);\n  };\n}\n\nfunction fetchMissing(missingTree) {\n  // Update lastFetchMissingPromise immediately, without waiting for\n  // the results to be delivered.\n  return new Promise(function (resolve, reject) {\n    Meteor.call(\n      \"__dynamicImport\",\n      missingTree,\n      function (error, resultsTree) {\n        error ? reject(error) : resolve(resultsTree);\n      }\n    );\n  });\n}\n\nfunction addToTree(tree, id, value) {\n  var parts = id.split(\"/\");\n  var lastIndex = parts.length - 1;\n  parts.forEach(function (part, i) {\n    if (part) {\n      tree = tree[part] = tree[part] ||\n        (i < lastIndex ? Object.create(null) : value);\n    }\n  });\n}\n\nfunction getNamespace(module, id) {\n  var namespace;\n\n  module.watch(module.require(id), {\n    \"*\": function (ns) {\n      namespace = ns;\n    }\n  });\n\n  // This helps with Babel interop, since we're not just returning the\n  // module.exports object.\n  Object.defineProperty(namespace, \"__esModule\", {\n    value: true,\n    enumerable: false\n  });\n\n  return namespace;\n}\n"]},"hash":"d5c0b3eb1e5206c060577a59afaf8fea8e9626f0"}

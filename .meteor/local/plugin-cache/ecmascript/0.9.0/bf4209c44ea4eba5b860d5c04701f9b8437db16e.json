{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"assert","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"assert"}]},{"source":"fs","imported":["readFileSync"],"specifiers":[{"kind":"named","imported":"readFileSync","local":"readFileSync"}]},{"source":"path","imported":["join","normalize"],"specifiers":[{"kind":"named","imported":"join","local":"pathJoin"},{"kind":"named","imported":"normalize","local":"pathNormalize"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]},{"source":"./security.js","imported":[],"specifiers":[]},{"source":"./client.js","imported":[],"specifiers":[]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/dynamic-import/server.js","filenameRelative":"packages/dynamic-import/server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"useNativeAsyncAwait":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/dynamic-import/server.js.map","sourceFileName":"packages/dynamic-import/server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"server"},"ignored":false,"code":"const module1 = module;\nlet assert;\nmodule1.watch(require(\"assert\"), {\n  default(v) {\n    assert = v;\n  }\n\n}, 0);\nlet readFileSync;\nmodule1.watch(require(\"fs\"), {\n  readFileSync(v) {\n    readFileSync = v;\n  }\n\n}, 1);\nlet pathJoin, pathNormalize;\nmodule1.watch(require(\"path\"), {\n  join(v) {\n    pathJoin = v;\n  },\n\n  normalize(v) {\n    pathNormalize = v;\n  }\n\n}, 2);\nlet check;\nmodule1.watch(require(\"meteor/check\"), {\n  check(v) {\n    check = v;\n  }\n\n}, 3);\nmodule1.watch(require(\"./security.js\"));\nmodule1.watch(require(\"./client.js\"));\nconst hasOwn = Object.prototype.hasOwnProperty;\nObject.keys(dynamicImportInfo).forEach(platform => {\n  const info = dynamicImportInfo[platform];\n\n  if (info.dynamicRoot) {\n    info.dynamicRoot = pathNormalize(info.dynamicRoot);\n  }\n});\nMeteor.methods({\n  __dynamicImport(tree) {\n    check(tree, Object);\n    this.unblock();\n    const platform = this.connection ? \"web.browser\" : \"server\";\n    const pathParts = [];\n\n    function walk(node) {\n      if (node && typeof node === \"object\") {\n        Object.keys(node).forEach(name => {\n          pathParts.push(name);\n          node[name] = walk(node[name]);\n          assert.strictEqual(pathParts.pop(), name);\n        });\n      } else {\n        return read(pathParts, platform);\n      }\n\n      return node;\n    }\n\n    return walk(tree);\n  }\n\n});\n\nfunction read(pathParts, platform) {\n  const {\n    dynamicRoot\n  } = dynamicImportInfo[platform];\n  const absPath = pathNormalize(pathJoin(dynamicRoot, pathJoin(...pathParts).replace(/:/g, \"_\")));\n\n  if (!absPath.startsWith(dynamicRoot)) {\n    throw new Meteor.Error(\"bad dynamic module path\");\n  }\n\n  const cache = getCache(platform);\n  return hasOwn.call(cache, absPath) ? cache[absPath] : cache[absPath] = readFileSync(absPath, \"utf8\");\n}\n\nconst cachesByPlatform = Object.create(null);\n\nfunction getCache(platform) {\n  return hasOwn.call(cachesByPlatform, platform) ? cachesByPlatform[platform] : cachesByPlatform[platform] = Object.create(null);\n}\n\nprocess.on(\"message\", msg => {\n  // The cache for the \"web.browser\" platform needs to be discarded\n  // whenever a client-only refresh occurs, so that new client code does\n  // not receive stale module data from __dynamicImport. This code handles\n  // the same message listened for by the autoupdate package.\n  if (msg && msg.refresh === \"client\") {\n    delete cachesByPlatform[\"web.browser\"];\n  }\n});","map":{"version":3,"sources":["packages/dynamic-import/server.js"],"names":["module1","module","assert","watch","require","default","v","readFileSync","pathJoin","pathNormalize","join","normalize","check","hasOwn","Object","prototype","hasOwnProperty","keys","dynamicImportInfo","forEach","platform","info","dynamicRoot","Meteor","methods","__dynamicImport","tree","unblock","connection","pathParts","walk","node","name","push","strictEqual","pop","read","absPath","replace","startsWith","Error","cache","getCache","call","cachesByPlatform","create","process","on","msg","refresh"],"mappings":"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","file":"packages/dynamic-import/server.js.map","sourcesContent":["import assert from \"assert\";\nimport { readFileSync } from \"fs\";\nimport {\n  join as pathJoin,\n  normalize as pathNormalize,\n} from \"path\";\n\nimport { check } from \"meteor/check\";\n\nimport \"./security.js\";\nimport \"./client.js\";\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nObject.keys(dynamicImportInfo).forEach(platform => {\n  const info = dynamicImportInfo[platform];\n  if (info.dynamicRoot) {\n    info.dynamicRoot = pathNormalize(info.dynamicRoot);\n  }\n});\n\nMeteor.methods({\n  __dynamicImport(tree) {\n    check(tree, Object);\n    this.unblock();\n\n    const platform = this.connection ? \"web.browser\" : \"server\";\n    const pathParts = [];\n\n    function walk(node) {\n      if (node && typeof node === \"object\") {\n        Object.keys(node).forEach(name => {\n          pathParts.push(name);\n          node[name] = walk(node[name]);\n          assert.strictEqual(pathParts.pop(), name);\n        });\n      } else {\n        return read(pathParts, platform);\n      }\n      return node;\n    }\n\n    return walk(tree);\n  }\n});\n\nfunction read(pathParts, platform) {\n  const { dynamicRoot } = dynamicImportInfo[platform];\n  const absPath = pathNormalize(pathJoin(\n    dynamicRoot,\n    pathJoin(...pathParts).replace(/:/g, \"_\")\n  ));\n\n  if (! absPath.startsWith(dynamicRoot)) {\n    throw new Meteor.Error(\"bad dynamic module path\");\n  }\n\n  const cache = getCache(platform);\n  return hasOwn.call(cache, absPath)\n    ? cache[absPath]\n    : cache[absPath] = readFileSync(absPath, \"utf8\");\n}\n\nconst cachesByPlatform = Object.create(null);\nfunction getCache(platform) {\n  return hasOwn.call(cachesByPlatform, platform)\n    ? cachesByPlatform[platform]\n    : cachesByPlatform[platform] = Object.create(null);\n}\n\nprocess.on(\"message\", msg => {\n  // The cache for the \"web.browser\" platform needs to be discarded\n  // whenever a client-only refresh occurs, so that new client code does\n  // not receive stale module data from __dynamicImport. This code handles\n  // the same message listened for by the autoupdate package.\n  if (msg && msg.refresh === \"client\") {\n    delete cachesByPlatform[\"web.browser\"];\n  }\n});\n"]},"hash":"bf4209c44ea4eba5b860d5c04701f9b8437db16e"}
